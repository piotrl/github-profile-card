/**
* github-profile-card - 3.2.0 | MIT
* (c) 2014 - 2025 Piotr Lewandowski | https://piotrl.github.io/github-profile-card/
*/

(() => {
  // src/gh-cache-storage.ts
  var CacheStorage = class {
    constructor(storage) {
      this.storage = storage;
      this.cacheName = "github-request-cache";
      this.requestCache = this.getCache() || {};
    }
    get(key) {
      return this.requestCache[key];
    }
    add(url, entry) {
      this.requestCache[url] = entry;
      this.storage.setItem(this.cacheName, JSON.stringify(this.requestCache));
    }
    getCache() {
      return JSON.parse(this.storage.getItem(this.cacheName));
    }
  };

  // src/gh-data-loader.ts
  var GitHubApiLoader = class {
    constructor() {
      this.apiBase = "https://api.github.com";
      this.cache = new CacheStorage(window.localStorage);
    }
    loadUserData(username, callback) {
      const request = this.apiGet(`${this.apiBase}/users/${username}`);
      request.success((profile) => {
        this.apiGet(profile.repos_url).success((repositories) => {
          callback({ profile, repositories }, null);
        });
      });
      request.error((result, request2) => {
        const error = this.identifyError(result, request2);
        callback(null, error);
      });
    }
    loadRepositoriesLanguages(repositories, callback) {
      const languagesUrls = this.extractLangURLs(repositories);
      const langStats = [];
      let requestsAmount = languagesUrls.length;
      languagesUrls.forEach((repoLangUrl) => {
        const request = this.apiGet(repoLangUrl);
        request.error(() => requestsAmount--);
        request.success((repoLangs) => {
          langStats.push(repoLangs);
          if (langStats.length === requestsAmount) {
            callback(langStats);
          }
        });
      });
    }
    identifyError(result, request) {
      const error = {
        message: result.message
      };
      if (request.status === 404) {
        error.isWrongUser = true;
      }
      const limitRequests = request.getResponseHeader("X-RateLimit-Remaining");
      if (Number(limitRequests) === 0) {
        const resetTime = request.getResponseHeader("X-RateLimit-Reset");
        error.resetDate = new Date(Number(resetTime) * 1e3);
        error.message = error.message.split("(")[0];
      }
      return error;
    }
    extractLangURLs(profileRepositories) {
      return profileRepositories.map((repository) => repository.languages_url);
    }
    apiGet(url) {
      const request = this.buildRequest(url);
      return {
        success: (callback) => {
          request.addEventListener("load", () => {
            if (request.status === 304) {
              callback(this.cache.get(url).data, request);
            }
            if (request.status === 200) {
              const response = JSON.parse(request.responseText);
              this.cache.add(url, {
                lastModified: request.getResponseHeader("Last-Modified"),
                data: response
              });
              callback(response, request);
            }
          });
        },
        error: (callback) => {
          request.addEventListener("load", () => {
            if (request.status !== 200 && request.status !== 304) {
              callback(JSON.parse(request.responseText), request);
            }
          });
        }
      };
    }
    buildRequest(url) {
      const request = new XMLHttpRequest();
      request.open("GET", url);
      this.buildApiHeaders(request, url);
      request.send();
      return request;
    }
    buildApiHeaders(request, url) {
      request.setRequestHeader("Accept", "application/vnd.github.v3+json");
      const urlCache = this.cache.get(url);
      if (urlCache) {
        request.setRequestHeader("If-Modified-Since", urlCache.lastModified);
      }
    }
  };

  // src/gh-dom.utils.ts
  function appendChildren($parent, nodes) {
    nodes.forEach((node) => $parent.appendChild(node));
  }
  function createProfile(children) {
    const $profile = document.createElement("div");
    $profile.classList.add("profile");
    appendChildren($profile, children);
    return $profile;
  }
  function createName(profileUrl, name) {
    const $name = document.createElement("a");
    $name.href = profileUrl;
    $name.className = "name";
    $name.appendChild(document.createTextNode(name));
    return $name;
  }
  function createAvatar(avatarUrl) {
    const $avatar = document.createElement("img");
    $avatar.src = avatarUrl;
    $avatar.className = "avatar";
    return $avatar;
  }
  function createFollowButton(username, followUrl) {
    const $followButton = document.createElement("a");
    $followButton.href = followUrl;
    $followButton.className = "follow-button";
    $followButton.innerHTML = "Follow @" + username;
    return $followButton;
  }
  function createFollowers(followersAmount) {
    const $followers = document.createElement("span");
    $followers.className = "followers";
    $followers.innerHTML = "" + followersAmount;
    return $followers;
  }
  function createFollowContainer(children) {
    const $followContainer = document.createElement("div");
    $followContainer.className = "followMe";
    appendChildren($followContainer, children);
    return $followContainer;
  }

  // src/gh-dom-operator.ts
  var DOMOperator = class {
    static clearChildren($parent) {
      while ($parent.hasChildNodes()) {
        $parent.removeChild($parent.firstChild);
      }
    }
    static createError(error, username) {
      const $error = document.createElement("div");
      $error.className = "error";
      $error.innerHTML = `<span>${error.message}</span>`;
      if (error.isWrongUser) {
        $error.innerHTML = `<span>Not found user: ${username}</span>`;
      }
      if (error.resetDate) {
        let remainingTime = error.resetDate.getMinutes() - (/* @__PURE__ */ new Date()).getMinutes();
        remainingTime = remainingTime < 0 ? 60 + remainingTime : remainingTime;
        $error.innerHTML += `<span class="remain">Come back after ${remainingTime} minutes</span>`;
      }
      return $error;
    }
    static createProfile(data) {
      const $followButton = createFollowButton(data.login, data.html_url);
      const $followers = createFollowers(data.followers);
      const $followContainer = createFollowContainer([$followButton, $followers]);
      const $avatar = createAvatar(data.avatar_url);
      const $name = createName(data.html_url, data.name);
      return createProfile([$avatar, $name, $followContainer]);
    }
    static createTopLanguagesSection() {
      const $langsList = document.createElement("ul");
      $langsList.className = "languages";
      return $langsList;
    }
    static createTopLanguagesList(langs) {
      return Object.keys(langs).map((language) => ({
        name: language,
        stat: langs[language]
      })).sort((a, b) => b.stat - a.stat).slice(0, 3).map((lang) => `<li>${lang.name}</li>`).reduce((list, nextElement) => list + nextElement);
    }
    static createRepositoriesHeader(headerText) {
      const $repositoriesHeader = document.createElement("span");
      $repositoriesHeader.className = "header";
      $repositoriesHeader.appendChild(document.createTextNode(`${headerText}`));
      return $repositoriesHeader;
    }
    static createRepositoriesList(repositories, maxRepos) {
      const $reposList = document.createElement("div");
      $reposList.className = "repos";
      repositories.slice(0, maxRepos).map(this.createRepositoryElement).forEach((el) => $reposList.appendChild(el));
      return $reposList;
    }
    static createRepositoryElement(repository) {
      const updated = new Date(repository.updated_at);
      const $repoLink = document.createElement("a");
      $repoLink.href = repository.html_url;
      $repoLink.title = repository.description;
      $repoLink.innerHTML = `
                <span class="repo-name"> ${repository.name} </span>
                <span class="updated">Updated: ${updated.toLocaleDateString()} </span>
                <span class="star"> ${repository.stargazers_count} </span>
            `;
      return $repoLink;
    }
  };

  // src/gh-profile-card.ts
  var GitHubCardWidget = class {
    constructor(options = {}) {
      this.apiLoader = new GitHubApiLoader();
      this.$template = this.findTemplate(options.template);
      this.extractHtmlConfig(options, this.$template);
      this.options = this.completeConfiguration(options);
    }
    init() {
      this.apiLoader.loadUserData(this.options.username, (data, err) => {
        this.userData = data;
        this.render(this.options, err);
      });
    }
    refresh(options) {
      this.options = this.completeConfiguration(options);
      this.render(this.options);
    }
    completeConfiguration(options) {
      const defaultConfig = {
        username: null,
        template: "#github-card",
        sortBy: "stars",
        // possible: 'stars', 'updateTime'
        headerText: "Most starred repositories",
        maxRepos: 5,
        hideTopLanguages: false
      };
      for (const key in defaultConfig) {
        defaultConfig[key] = options[key] || defaultConfig[key];
      }
      return defaultConfig;
    }
    findTemplate(templateCssSelector = "#github-card") {
      const $template = document.querySelector(
        templateCssSelector
      );
      if (!$template) {
        throw `No template found for selector: ${templateCssSelector}`;
      }
      $template.className = "gh-profile-card";
      return $template;
    }
    extractHtmlConfig(widgetConfig, $template) {
      widgetConfig.username = widgetConfig.username || $template.dataset["username"];
      widgetConfig.sortBy = widgetConfig.sortBy || $template.dataset["sortBy"];
      widgetConfig.headerText = widgetConfig.headerText || $template.dataset["headerText"];
      widgetConfig.maxRepos = widgetConfig.maxRepos || parseInt($template.dataset["maxRepos"], 10);
      widgetConfig.hideTopLanguages = widgetConfig.hideTopLanguages || $template.dataset["hideTopLanguages"] === "true";
      if (!widgetConfig.username) {
        throw "Not provided username";
      }
    }
    render(options, error) {
      const $root = this.$template;
      DOMOperator.clearChildren($root);
      if (error) {
        const $errorSection = DOMOperator.createError(error, options.username);
        $root.appendChild($errorSection);
        return;
      }
      const repositories = this.userData.repositories;
      this.sortRepositories(repositories, options.sortBy);
      const $profile = DOMOperator.createProfile(this.userData.profile);
      if (!options.hideTopLanguages) {
        $profile.appendChild(this.createTopLanguagesSection(repositories));
      }
      $root.appendChild($profile);
      if (options.maxRepos > 0) {
        const $reposHeader = DOMOperator.createRepositoriesHeader(
          options.headerText
        );
        const $reposList = DOMOperator.createRepositoriesList(
          repositories,
          options.maxRepos
        );
        $reposList.insertBefore($reposHeader, $reposList.firstChild);
        $root.appendChild($reposList);
      }
    }
    createTopLanguagesSection(repositories) {
      const $topLanguages = DOMOperator.createTopLanguagesSection();
      this.apiLoader.loadRepositoriesLanguages(
        repositories.slice(0, 10),
        (langStats) => {
          const languagesRank = this.groupLanguagesUsage(langStats);
          $topLanguages.innerHTML = DOMOperator.createTopLanguagesList(languagesRank);
        }
      );
      return $topLanguages;
    }
    groupLanguagesUsage(langStats) {
      const languagesRank = {};
      langStats.forEach((repoLangs) => {
        for (const language in repoLangs) {
          languagesRank[language] = languagesRank[language] || 0;
          languagesRank[language] += repoLangs[language];
        }
      });
      return languagesRank;
    }
    sortRepositories(repos, sortyBy) {
      repos.sort((firstRepo, secondRepo) => {
        if (sortyBy === "stars") {
          const starDifference = secondRepo.stargazers_count - firstRepo.stargazers_count;
          if (starDifference !== 0) {
            return starDifference;
          }
        }
        return this.dateDifference(secondRepo.updated_at, firstRepo.updated_at);
      });
    }
    dateDifference(first, second) {
      return new Date(first).getTime() - new Date(second).getTime();
    }
  };

  // src/css/base.scss
  var css = `@charset "UTF-8";
/**
 * Github widget styles 
 * ------------------------------------------------------------------
 */
.gh-profile-card {
  /* followers number */
  /* List of repositories */
}
.gh-profile-card {
  width: 280px;
  border-radius: 5px;
  font-size: 16px;
  font-family: Helvetica;
  background: #fafafa;
  border-width: 1px 1px 2px;
  border-style: solid;
  border-color: #ddd;
  overflow: hidden;
}
.gh-profile-card a {
  text-decoration: none;
  color: #444;
}
.gh-profile-card a:hover {
  color: #4183c4;
}
.gh-profile-card .name {
  display: block;
  font-size: 1.2em;
  font-weight: bold;
  color: #222;
}
.gh-profile-card .error {
  font-size: 0.8em;
  color: #444;
  padding: 10px;
}
.gh-profile-card .error span {
  display: block;
  border-bottom: 1px solid #ddd;
  padding-bottom: 5px;
  margin-bottom: 5px;
}
.gh-profile-card .error span.remain {
  text-align: center;
  font-weight: bold;
}
.gh-profile-card .profile {
  background: #fff;
  overflow: hidden;
  padding: 15px 10px;
  padding-bottom: 0;
}
.gh-profile-card .stats {
  padding: 5px;
}
.gh-profile-card .languages {
  position: relative;
  clear: both;
  margin: 0 -10px;
  padding: 10px;
  min-height: 36px;
  border-top: 1px solid #dedede;
  font-size: 0.8em;
}
.gh-profile-card .languages::before {
  position: absolute;
  top: -0.7em;
  background: #fff;
  padding-right: 5px;
  content: "Top languages";
  font-style: italic;
  color: #555;
}
.gh-profile-card .languages li {
  display: inline-block;
  color: #444;
  font-weight: bold;
  margin-left: 10px;
}
.gh-profile-card .languages li::after {
  content: "\u2022";
  margin-left: 10px;
  color: #999;
}
.gh-profile-card .languages li:last-child::after {
  content: "";
}
.gh-profile-card .followMe {
  margin-top: 3px;
}
.gh-profile-card .follow-button {
  font-size: 0.8em;
  color: #333;
  float: left;
  padding: 0 10px;
  line-height: 1.5em;
  border: 1px solid #d5d5d5;
  border-radius: 3px;
  font-weight: bold;
  background: #eaeaea;
  background-image: linear-gradient(#fafafa, #eaeaea);
  text-shadow: 0 1px 0 rgba(255, 255, 255, 0.9);
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.gh-profile-card .follow-button:hover {
  color: inherit;
  background: #ddd;
  background-image: linear-gradient(#eee, #ddd);
}
.gh-profile-card .followMe span {
  position: relative;
  background: #fff;
  margin-left: 8px;
  padding: 0 5px;
  color: #444;
  font-size: 0.8em;
  border: 1px solid;
  border-color: #bbb;
}
.gh-profile-card .followMe span::before {
  content: "";
  position: absolute;
  display: block;
  width: 5px;
  height: 5px;
  left: -4px;
  top: 30%;
  background: inherit;
  border-left: 1px solid;
  border-top: 1px solid;
  border-color: inherit;
  -moz-transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
  -ms-transform: rotate(-45deg);
  transform: rotate(-45deg);
}
.gh-profile-card .avatar {
  width: 64px;
  height: 64px;
  float: left;
  margin: 0 10px 15px 0;
  margin-left: 0;
  border-radius: 5px;
  box-shadow: 0 0 2px 0 #ddd;
}
.gh-profile-card .repos {
  clear: both;
}
.gh-profile-card .repos .header {
  display: block;
  width: 100%;
  font-weight: bold;
  background: #eaeaea;
  background-image: linear-gradient(#fafafa, #eaeaea);
  border: solid #d5d5d5;
  border-width: 1px 0;
  color: #555;
  font-size: 0.8em;
  padding: 5px 10px;
}
.gh-profile-card .repos a {
  position: relative;
  display: block;
  padding: 7px 10px;
  font-size: 0.9em;
  border-top: 1px solid #ddd;
}
.gh-profile-card .repos a:first-of-type {
  border: none;
}
.gh-profile-card .repos .repo-name {
  max-width: 280px;
  font-weight: bold;
  text-overflow: ellipsis;
}
.gh-profile-card .repos .updated {
  display: block;
  font-size: 0.75em;
  font-style: italic;
  color: #777;
}
.gh-profile-card .repos .star {
  position: absolute;
  font-size: 0.9em;
  right: 0.5em;
  top: 1.1em;
  color: #888;
}
.gh-profile-card .repos .star::after {
  content: "\xA0\u2605";
  font-size: 1.1em;
  font-weight: bold;
}`;
  document.head.appendChild(document.createElement("style")).appendChild(document.createTextNode(css));

  // src/gh-widget-init.ts
  window.GitHubCard = GitHubCardWidget;
  document.addEventListener("DOMContentLoaded", () => {
    const $defaultTemplate = document.querySelector("#github-card");
    if ($defaultTemplate) {
      const widget = new GitHubCardWidget();
      widget.init();
    }
  });
})();
